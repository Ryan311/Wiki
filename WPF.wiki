%toc

*WPF编程宝典：使用C# 2012和.Net 4.5 第5版*
{{{
    WPF，微软在Win Form的思路上走到死胡同后，终于痛下决心用正确的方法开发UI库了。21世纪的UI一定是定义出来的，绝对不能是代码写出来的，所以有了XAML这个强大的定义工具，
    不但可以定义UI布局，还包括图形动画效果，消息响应方式等。配合C#这种优秀的语言，更是如虎添翼。但是问题也很明显，就是过于庞大，不仅开发时要用到庞大的IDE和设计工具，
    发行的安装包也十分巨大，所以目前还是很少有人拿他写通用软件客户端的，大多是做企业项目时写专用客户端。
    大概4-5年前吧疼讯曾经用WPF写了个QQ，但是只实现了基本功能就已经比C++客户端大好多了，而且运行缓慢，主要是太吃内存，而且那时WPF的优化还不充分。
    
    MFC和QT是C++中常见的GUI框架,而WinForm和WPF是C#中常用的框架,不过我们一般很少叫WinForm框架,可能直接叫图形控件类库更多点.反正只是个称呼罢了,爱咋叫就咋叫.
    另外WinForm与WPF(即Windows Form与Windows Presentation Foundation,用于windows的上的桌面应用开发)都只是提供了一堆GUI类库,
    而MFC与QT除了一堆GUI类库外还提供了其他很多类.功能更强大.
    
    C++中的MFC和C#中的WinForm有点类似,而C++中的QT与C#中的WPF又有点类似
    
    MFC,QT与WinForm,WPF简介:
        http://blog.csdn.net/weiwenhp/article/details/8442553
}}}

= Windows Presentation Foundation =
独立于平台、提供更广泛的应用程序类型

== Features ==
*   WPF通过DirectX提供硬件加速功能
    *   WPF底层的图形技术不再是GDI、GDI+, 而是DirectX， DirectX在渲染图形时会将尽可能多的工作递交给图形处理单元（GPU）去处理， GPU是显卡专用处理器
*   WPF不是使用物理像素设置尺寸， 而是使用可进行缩放以适应不同显示器分辨率的设备无关单位
    *   传统的Windwos应用程序是不可伸缩的
    *   WPF会根据系统DPI设置进行缩放， 并不会根据物理显示设备的DPI进行缩放
    *   WPF窗口以及其中的所有元素都使用与设备无关的单位进行度量， 定义为1/96英寸
*   用户界面由XAML语言来编写

== Layout ==
*   WPF用不同的容器(container)安排布局， 抵制基于坐标的布局
*   WPF布局容器都是派生自System.Windows.Controls.Panel抽象类的面板， 派生自Panel的类
    *   StackPanel
    *   WrapPanel   
    *   DockPanel
    *   Grid        前三个是最简单的布局容器， Grid是最强大的布局容器
    *   UniformGrid
    *   Canvas      允许使用精确的坐标放置元素

== WPF属性模型 ==
*   在WPF的核心特性(如动画、数据绑定以及样式)中需要嵌入依赖项属性
*   WPF元素提供的大多数属性都是依赖项属性


== WPF事件模型 ==
*   WPF通过事件路由(event routing)的概念增强了.NET事件模型， 事件路由允许源自某个元素的事件由另一个元素引发
*   路由事件是具有更强传播能力的事件， 它们可在元素树中向上冒泡和向下隧道传播， 并且沿着传播路径被事件处理程序处理
    *   冒泡路由    在包含层次中向上传递路由事件
    *   隧道路由    包含层次中向下传递路由事件， 在事件到达恰当的控件之前为预览事件提供了机会， 以Preview开头的事件
    *   如果隧道路由事件标记为已处理过， 那就不会发生冒泡路由事件， 因为两个事件共享RoutedEventArgs类的同一个实例
     
== 控件类 ==
*   继承自System.Windows.Control类的元素
*   WPF窗口充满了各种元素， 但是只有一部分是控件， 控件通常被描述为与用户交互的元素--能接收焦点并接受键盘或鼠标输入的元素
*   所有控件都包含背景和前景概念， 通常背景是控件的表面， 而前景是文本

== Application类 ==
*   每个运行中的WPF应用程序都由System.Windwos.Application类的一个实例来表示， 该类跟踪在应用程序中打开的所有窗口， 决定何时关闭应用程序， 并引发可执行初始化和清除操作的应用程序事件

== 元素绑定 ==
*   元素之间的绑定
*   元素与非元素之间的绑定

== WPF命令模型 ==
*   使用路由事件可响应广泛的鼠标和键盘动作， 但是事件是非常低级的元素
*   在实际应用程序中， 功能被划分成一些高级的任务（即所谓的命令）， 将控件连接到命令， 从而不重复编写事件处理程序
*   命令模型由4个重要元素
    *   命令
    *   命令绑定
    *   命令源
    *   命令目标
