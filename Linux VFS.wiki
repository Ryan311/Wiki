%toc

VFS (Virtual File System)
为支持各种本机文件系统， 且在同时允许访问其他操作系统的文件， Linux内核在用户空间(或C标准库)和文件系统实现之间引入了一个抽象层， 该抽象层称之为虚拟文件系统
VFS不仅为文件系统提供了方法和抽象， 还支持文件系统中对象(或文件)的统一视图
VFS是一个胶水层， 位于内核的底层和用户层之间。 它提供了各种抽象数据结构来表示文件和inode， 而真实文件系统的实现必须填充这些结构， 使得应用程序无需考虑底层文件系统， 总是可以使用同样的接口访问和操作文件。

文件系统类型：
*   基于磁盘的文件系统
*   虚拟文件系统
*   网络文件系统

= 通用文件模型 =
VFS提供了一种结构模型， 包含了一个强大文件系统所应具备的所有组件。但该模型只存在于虚拟中， 必须使用各种对象和函数指针与每种文件系统适配。
所有文件系统的实现都必须提供与VFS定义的结构配合的例程， 以弥合两种视图之间的差异！！！

在处理文件时， 内核与用户空间使用的主要对象是不同的。
*   对用户来说， 一个文件由一个文件描述符标识， 该描述符是一个整数， 是在打开文件时由内核分配阀， 只在一个进程内部有效， 所有文件操作都用它来标识文件
*   内核处理文件的关键是inode， 每个文件（或目录）都有且只有一个对应的inode， 其中包含元数据(如访问上隉、上次修改时间等)和指向文件数据指针， 但不包括文件名

== inode ==
inodes用来构成文件系统的目录层次结构， inode成员分为两类：
*   描述文件状态的元数据
*   保存实际文件内容的指针

目录是特殊的文件， 它的数据段不包含普通数据， 而是目录项， 每个目录项由两个成员组成：
*   该目录项的数据所在inode的编号
*   文件或目录的名称
系统中所有的inode都有一个特定的编号， 用于唯一地标识各个inode. 文件与inode之间的关联即通过该编号建立.

== 链接 ==
*   符号链接    -> 对每个符号链接都使用一个独立的inode， 该inode的数据段包含一个字符吕， 给出了连接目标的路径
*   硬链接      -> ？？？
 
== 编程接口 ==
用户进程和内核的VFS实现之间接口照例由系统调用组成， 其中大数涉及对文件、目录和一般意义上的文件系统的操作

= VFS结构 =
VFS由两部分组成：   文件和文件系统
VFS在对底层文件系统的访问时， 没有使用固定的函数， 而是使用了函数指针。
这引动函数指针保存在两个结构中， 包括了所有的相关的函数：
1)  inode操作(i_op)： 创建链接、文件重命名、在目录中生成新文件、删除文件
2)  文件操作(i_fop)： 作用于文件的数据内容。 它们包含一些显示的操作(读和写), 还包括如设置文件位置指针和创建内存映射之类的操作

== inode ==
*   <fs.h>  struct inode
*   inode结构存在于内存中， 因而包含一些实际介质上存储的inode所没有的成员。这些是由内核自身在从底层文件系统读入信息时生成或动态建立的。
*   还有一些文件系统， 并没有使用经典意义上的inode， 因此必须从其包含的数据中提取信息并生成这里给出的形式。
*   当inode表示设备文件时， 成员i_rdev表示设备， 通过它能找到对应的设备实例。 匿名联合包含了指向设备专用数据结构的指针
*   对inode的操作包含在两个函数数组指针中， i_op和i_fop
*   inode链表
    *   每个inode都有一个i_list成员， 可以将inode存储在一个链表中， 根据inode状态， 它可能有3种主要的情况
        *   inode存在于内存中， 未关联到任何文件， 也不处于活动使用状态
        *   inode存在内存中， 正在由一个或多个进程使用， 通常表示一个文件
        *   inode处于活动使用状态， 其数据内容已经改变， 与存储介质上的内容不同， 称为脏的inode
    *   fs/inode.c中内核定义了两个全局变量用作表头， inode_unused用于有效但非活动的i_node(第一类)， inode_in_use用于所有使用但未改变的inode(第二类), 脏的inode保存在超级块的链表中。
*   inode不仅出现在特定的链表中， 还在一个散列中， 以支持根据inode编号和超级块快速访问inode，该散列表是一个数组， 在fs/inode.c中的inode_init函数初始化

== 特定于进程的信息 ==
*   文件描述符用于在一个进程内唯一标识打开的文件, 它是struct file数组的索引
*   进程的task_struct结构中与文件相关的成员， fs(文件系统相关数据), files(包含当前进程的各个文件描述符)
*   task_struct->struct files_struct files->struct file(该结构中包含内核看到的文件的特征信息) -> struct path(提供了文件名与inode之间的关联)
*   task_struct->struct fs_struct   特定于进程的数据， 文件权限、进程根目录、文件系统等信息

== 目录项缓存 ==
*   struct dentry   该结构的主要用途是建立文件名与相关的inode之间的关联
*   在VFS连同文件系统实现读取的一个目录项(目录或文件)的数据之后， 则创建一个dentry实例， 以缓存找到的数据
*   每个由VFS发送到底层实现的请求， 都会导致创建一个新的dentry对象， 以保存请求的结果。这些对象保存在一个缓存中， 在下一次需要时可以更快速的访问。
*   缓存如何组织， 包含两部分：
    *   一个散列表(dentry_hashtable)包含了所有的dentry对象
    *   一个LRU(最近最少使用， last rencently used)链表， 其中不再使用的对象将授予一个最后宽限期， 宽限期过后才从内存移除
*   dentry_operations结构保存了指向各种特定于文件系统可以对dentry对象执行的操作的函数指针

= VFS对象操作 =
== 文件系统操作 ==
*   注册文件系统    fs/super.c中的register_filesystem用来向内核注册文件系统
    *   struct file_system_type     描述文件系统类型的结构
    *   每个装载的文件系统， 在内在中都创建一个超级块结构， 该结构保存了文件系统它本身和装载点的有关信息
    *   同一文件系统类型可能对应多个超级块结构， 这些超级块聚焦在一个单向链表中， file_system_type->fs_supers是表头
*   装载和卸载
    *   struct vfsmount     每个装载的文件系统都对应一个vfsmount结构的实例
    *   struct super_block  每个文件系统都有且仅有一个超级块实例， struct super_operations包含对超级块操作的函数指针, 操作的实现由底层文件系统提供。

== 文件操作 ==
*   VFS以各种系统调用的形式提供用于文件处理的接口函数
*   fs/namei.c          path_look()     内核使用该函数查找路径或文件名， nameidata用于保存查找结果
*   fs/open.c           sys_open()      打开文件
*   fs/read_write.c     sys_read(), sys_write()   读取与写入

