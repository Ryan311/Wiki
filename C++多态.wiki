%toc

= is-a 关系 =
无需进行显示类型转换， 基类指针就可以指向派生类对象， 基类引用可以引用派生类对象。
反过来行不通， 即不能在不进行显示类型转换的情况下， 将派生类指针或引用指向基类对象。

= 类的成员函数重载 =
成员函数名相同， 但是参数不同的多个函数称为重载函数， 多态的一种表现

= 多态公有继承 =
*   虚函数(virtual)： 当类的成员函数被声明为虚函数时， 程序将根据引用或指针指向的对象的类型来选择方法， 而不是使用引用类型或指针类型来选择方法
*   经常在基类中将派生类会重新定义的方法声明为虚方法， 方法在基类中被声明为虚后， 它在派生类中将自动成为虚方法。
*   方法在基类中被声明为虚后， 它在派生类中将自动成为虚方法， 但在派生类中也使用关键字virtual来指出哪些函数是虑函数是一个好习惯
*   构造函数不能是虚函数，派生类创建对象时要使用派生类的构造函数， 然后使用基类的一个构造函数
*   析构函数应当声明为虚函数， 通常给基类提供一个虚析构函数
*   友元不能是虚函数， 因它不是类成员， 只有成为才能是虚函数

= 静态联编和动态联编 =
*   将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)
*   C++中， 由于使用了函数重载， 编译器必须查看函数参数以及函数名才能确定使用哪个函数 ==> C/C++编译器在编译过程中进行联编， 称为静态联编
*   C++中， 由于使用了虚函数， 使用哪个函数不能在编译时确定 ==> 编译器必须生成能够在程序运行时选择正确的虚函数的代码， 称为动态联编

= 抽象基类(abstract base class, ABC) =
*   纯虚函数：  C++中使用它来提供未实现的成员函数， 纯虚函数的结尾处为=0
*   至少包含一个纯虚函数的类称为抽象基类, 它只能作为基类， 且不能创建该类的对象。（在原型中定义的纯虚函数， 在ABC中也可以定义该函数实现）

= 多重继承 =
*   虚基类(virtual base class)  使得从多个类(它们的基类相同)派生出的对象只继承一个基类对象

    class Singer: virtual public Worker {...};
    class Waiter: virtual public Worker {...};
    class SingerWaiter: public Singer, Waiter {...};

SingerWaiter对象将只包含Worker对象的一个副本， 继承的Singer和Waiter对象共享一个Worker对象， 而不是各自引入自己的Worker对象副本
*   非虚基类MI
*   虚基类MI

