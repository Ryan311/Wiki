%toc


Doc:
*   Python中使用C代码：以 Numpy 为例 :   https://segmentfault.com/a/1190000000479951
*   SWIG:   http://www.swig.org/tutorial.html

= Basic =
在python代码中支持c/c++本机代码的许多不同方法， 通常这个过程叫作包裹(wrapping)。
有以下几个技术：
*   Python-C-Api
    *   Python-C-API是标准Python解释器(就是所谓的CPython)的支柱。使用这个API可以用C或C++语言编写Python扩展。
*   Ctypes
    *   Ctypes是一个Python的外部函数库。它提供了兼容C的数据类型。并且允许调用DLL或共享库中的函数。它能够被用来将这些库用纯Python包裹。
*   SWIG(简单包裹和接口生成)
*   Cython          最优先使用的方法
    *   Cython语言是Python的超集，包含额外的结构允许你调用C函数，将变量和类属性解释为C类型。
| x            | Part of CPython | Compiled | Autogenerated | Numpy Support |
| Python-C-Api | True            | True     | False         | True          |
|Ctypes        | True             | False    |  False         |  True       |
|Swig          | False            | True     |  True          |  True       |
|Cython        | False            | True     |  True          |  True       |
相比所有技术中，Cython是最现代最高级的了。特别是，通过向Python代码中添加类型增量优化代码的能力是独一无二的。


创建Python扩展需3个步骤：
*   创建应用程序代码
*   利用样板来包装代码
*   编译与测试

用样板包装代码， 分为4步：
*   包含Python头文件, "Python.h"
*   为每个模块的每一个函数增加一个形如PyObject* Module_func()的包装函数
*   为每个模块增加一个形如PyMethodDef ModuleMethods[]的数组
*   增加模块初始化函数 void initModule()

Python与C/C++之间转换：
| 函数                              | 描述                                                                                                                                    |
| Python到C                         |                                                                                                                                         |
| int PyArg_ParseTuple()            | 把Python传来的参数转换为C, Parse the paras of a func that takes only positional paras into local variables              |
| int PyArg_ParseTupleAndKeywords() | 与PyArg_ParseTuple()作用相同， Parse the paras of a func that takes both positional and keyword paras into local variable |
| C到Python                         |                                                                                                                                         |
| PyObject* Py_BuildValue()         | 把C的数据转换为Python的一个或一组对象， 然后返回之                                                                                      |

数据转换的通用代码
| 格式代码 | Python型 | C/C++型        |
| s        | str      | char*          |
| z        | str/None | char*/NULL     |
| i        | int      | int            |
| l        | long     | long           |
| c        | str      | char           |
| d        | float    | double         |
| D        | complex  | Py_Complex*    |
| O        | (any)    | PyObject*      |
| S        | str      | PyStringObject |


{{{
    Py_BuildValue("")                        None
    Py_BuildValue("i", 123)                  123
    Py_BuildValue("iii", 123, 456, 789)      (123, 456, 789)
    Py_BuildValue("s", "hello")              'hello'
    Py_BuildValue("ss", "hello", "world")    ('hello', 'world')
    Py_BuildValue("s#", "hello", 4)          'hell'
    Py_BuildValue("()")                      ()
    Py_BuildValue("(i)", 123)                (123,)
    Py_BuildValue("(ii)", 123, 456)          (123, 456)
    Py_BuildValue("(i,i)", 123, 456)         (123, 456)
    Py_BuildValue("[i,i]", 123, 456)         [123, 456]
    Py_BuildValue("{s:i,s:i}",
                  "abc", 123, "def", 456)    {'abc': 123, 'def': 456}
    Py_BuildValue("((ii)(ii)) (ii)",
                  1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6)) 
}}}

= Example =
== Source ==
C代码：
{{{"class = c"
    int fac(int n)
    {
        if(n<2) return(1);
        return (n)*fac(n-1);
    }
}}}

Python包装函数：
{{{"class = c"
    static PyObject* Extest_fac(PyObject *self, PyObject *args)
    {
        int res;
        int num;
        PyObject* retval;

        res = PyArg_ParseTuple(args, "i", &num);
        if(!res) return NULL;

        res = fac(num);
        retval = (PyObject*)Py_BuildValue("i", res);
        return retval;
    }
    
    # Using PyArg_ParseTupleAndKeywords
    static PyObject *
    Extest_parrot(PyObject *self, PyObject *args, PyObject *keywds)
    {
        int voltage;
        char *state = "a stiff";
        char *action = "voom";
        char *type = "Norwegian Blue";

        static char *kwlist[] = {"voltage", "state", "action", "type", NULL};

        if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist, &voltage, &state, &action, &type))
            return NULL;

        printf("-- This parrot wouldn't %s if you put %i Volts through it.\n", action, voltage);
        printf("-- Lovely plumage, the %s -- It's %s!\n", type, state);
        Py_INCREF(Py_None);
        return Py_None;
    }

    
    #创建数组， 包含所有的包装函数
    static PyMethodDef ExtestMethods[] = {
        {"fac", Extest_fac, METH_VARARGS, "Print fac out"},
        {"parrot", Extest_parrot, METH_VARARGS | METH_KEYWORDS, "Print a lovely skit to standard output."},
        ......          # 可以有多个包装函数
        {NULL, NULL, 0, NULL},
    }

    #模块初始化函数
    PyMODINIT_FUNC
    initExtest(void)
    {
        (void) Py_InitModule("Extest", ExtestMethods);
    }

}}}

== Build ==
标准python构建系统distutils支持从setup.py编译C扩展，这相当方便。 创建setup.py
{{{
    from distutils.core import setup, Extension

    # define the extension module
    Extest = Extension('Extest', sources=['Extest.c'])

    # run the setup
    setup(ext_modules=[Extest])
}}}
运行setup.py编译和连接代码
>python setup.py build_ext --inplace
安装到Python中
>python setup.py install

== 导入并测试== 
>> import Extest
>> Extest.fac(5)
>> Extest.parrot(voltage=1, state="a tiff", action="room", type="Blue")

注意：以上Python-C-Api示例主要为了展示需要。因为大多其它技术实际上依赖这个，所以最好对它如何工作有个高层次的了解。在99%的用例中你最好使用其它技术。

= swig =
*   http://www.swig.org/index.php
*   sudo apt-get install swig
SWIG, 简化包裹接口生成器，是一个将不同高级编程语言包括Python链接到用C和C++写的程序上的软件开发工具。SWIG重要的功能是，它能自动为你生成包裹代码。
<br>这就开发时间来说是个优势，也可能是个负担。生成文件趋于巨大，读起来不友好，包裹过程的结果就是多个间接层，可能有点难以理解。

== Example ==
*   example.c
{{{
     #include <time.h>
     double My_variable = 3.0;
     
     int fact(int n) {
         if (n <= 1) return 1;
         else return n*fact(n-1);
     }
     
     int my_mod(int x, int y) {
         return (x%y);
     }
        
     char *get_time()
     {
         time_t ltime;
         time(&ltime);
         return ctime(&ltime);
     }
}}}

*   Interface file
{{{
    /* example.i */
    %module example
    %{
        /* Put header files here or function declarations like below */
        extern double My_variable;
        extern int fact(int n);
        extern int my_mod(int x, int y);
        extern char *get_time();
    %}

    extern double My_variable;
    extern int fact(int n);
    extern int my_mod(int x, int y);
    extern char *get_time();
}}}

*   Building a Python module by hand
    *   >swig -python example.i
    *   >gcc -O2 -fpic -c example.c example_wrap.c -I/usr/local/include/python2.7
        *   The -fPIC option tells GCC to generate position-independent code (PIC) which is required for most architectures 
    *   >ld -shared example.o example_wrap.o -o _example.so 

*   The preferred approach to building an extension module for python is to compile it with distutils
{{{"class = python"
    #!/usr/bin/env python
    """
    setup.py file for SWIG example
    """
    from distutils.core import setup, Extension

    example_module = Extension('_example',
                   sources=['example_wrap.c', 'example.c'],
                   )

    setup (name = 'example',
           version = '0.1',
           author      = "SWIG Docs",
           description = """Simple swig example from docs""",
           ext_modules = [example_module],
           py_modules = ["example"],
           )
}}}
    *   swig -python example.i
    *   python setup.py build_ext --inplace
        *   build_ext -- telling distutils to build extensions
        *   --inplace -- this tells distutils to put the extension lib in the current dir 

*   Test in python
    *   import example
    *   example.fact(4)

= Cython =
优势:
*    类Python的语言来写C扩展
*    自动生成代码
*    支持增量优化
*    包含一个GNU调试器扩展
*    支持C++(自从0.13版本)

Cython通过numpy.pyx文件支持Numpy, 这允许你将Numpy数组类型添加到Cython代码。

= Numpy = 
类似于Python-C-API,Numpu自身作为C扩展实现也有Numpy-C-API。这个API可以在写自定的C扩展时，被用来从C创建和操作Numpy数组。

You can add the following code snippet to your setup.py file to download _numpy.i_ from Github at build time:
{{{"class = python"
    import re
    import requests
    import numpy

    np_version = re.compile(r'(?P<MAJOR>[0-9]+)\.'
                            '(?P<MINOR>[0-9]+)') \
                            .search(numpy.__version__)
    np_version_string = np_version.group()
    np_version_info = {key: int(value)
                       for key, value in np_version.groupdict().items()}

    np_file_name = 'numpy.i'
    np_file_url = 'https://raw.githubusercontent.com/numpy/numpy/maintenance/' + \
                  np_version_string + '.x/tools/swig/' + np_file_name
    if(np_version_info['MAJOR'] == 1 and np_version_info['MINOR'] < 9):
        np_file_url = np_file_url.replace('tools', 'doc')

    chunk_size = 8196
    with open(np_file_name, 'wb') as file:
        for chunk in requests.get(np_file_url,
                                  stream=True).iter_content(chunk_size):
            file.write(chunk)
}}}
