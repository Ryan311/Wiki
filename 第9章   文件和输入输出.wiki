*   9C1.   文件过滤. 显示一个文件的所有行, 忽略以井号( # )开头的行. 这个字符被用做 Python , Perl, Tcl, 等大多脚本文件的注释符号. 
*附加题*: 处理不是第一个字符开头的注释. 
 
*   9C2.   文件访问. 提示输入数字 N 和文件 F, 然后显示文件 F 的前 N 行. 
 
*   9C3.   文件信息. 提示输入一个文件名, 然后显示这个文本文件的总行数. 
{{{"class = "brush:python"

}}}
 
*   9C4.   文件访问. 写一个逐页显示文本文件的程序. 提示输入一个文件名, 每次显示文本 文件的 25 行, 暂停并向用户提示"按任意键继续.", 按键后继续执行. 
 
*   9C5.   考试成绩. 改进你的考试成绩问题(练习 5 -3 和 6-4), 要求能从多个文件中读入考
试成绩. 文件的数据格式由你自己决定. 
 
*   9C6.   文件比较. 写一个比较两个文本文件的程序. 如果不同, 给出第一个不同处的行号和
列号. 
 
*   9C7.   解析文件. Win32 用户: 创建一个用来解析 Windows .ini 文件的程序. POSIX 用户: 
创建一个解析 /etc/serves 文件的程序. 其它平台用户: 写一个解析特定结构的系统配置文件的
程序. 
 
*   9C8.  模块研究. 提取模块的属性资料. 提示用户输入一个模块名(或者从命令行接受输入). 
然后使用 dir() 和其它内建函数提取模块的属性, 显示它们的名字, 类型, 值. 
 
*   9C9.   Python 文档字符串. 进入 Python 标准库所在的目录. 检查每个 .py 文件看是否有 __doc__ 字符串, 如果有, 对其格式进行适当的整理归类. 你的程序执行完毕后, 应该会生成一个
漂亮的清单. 里边列出哪些模块有文档字符串, 以及文档字符串的内容. 清单最后附上那些没有文 档字符串模块的名字. 
*附加题*: 提取标准库中各模块内全部类(class)和函数的文档. 

*   9C10.   家庭理财. 创建一个家庭理财程序. 你的程序需要处理储蓄, 支票, 金融市场, 定
期存款等多种帐户. 为每种帐户提供一个菜单操作界面, 要有存款, 取款, 借, 贷等操作. 另外还
要提供一个取消操作选项. 用户退出这个程序时相关数据应该保存到文件里去(出于备份的目的, 
程序执行过程中也要备份.) 
 
*   9C11.   Web 站点地址. 
a) 编写一个 URL 书签管理程序. 使用基于文本的菜单, 用户可以添加, 修改或者删除书签数
据项. 书签数据项中包含站点的名称, URL 地址, 以及一行简单说明(可选). 另外提供检索功能, 
可以根据检索关键字在站点名称和 URL 两部分查找可能的匹配. 程序退出时把数据保存到一个磁
盘文件中去; 再次执行时候加载保存的数据. 
 
b)改进 a) 的解决方案, 把书签输出到一个合法且语法正确的 HTML 文件(.html 或 htm )中, 
这样用户就可以使用浏览器查看自己的书签清单. 另外提供创建"文件夹"功能, 对相关的书签进行
分组管理.  
 
附加题: 请阅读 Python 的 re 模块了解有关正则表达式的资料, 使用正则表达式对用户输入
的 URL 进行验证. 
 
*   9C12.   用户名和密码. 
回顾练习 7-5 , 修改代码使之可以支持"上次登录时间". 请参阅 time 模块中的文档了解如
何记录用户上次登录的时间. 另外提供一个"系统管理员", 它可以导出所有用户的用户名, 密码
(如果想要的话，你可以把密码加密), 以及"上次登录时间".  
a)  数 据 应 该 保 存 在 磁 盘 中 ,  使 用 冒 号 (  :  ) 分 割 ,  一 次 写 入 一 行 ,  例 如 
"joe:boohoo:953176591.145", 文件中数据的行数应该等于你系统上的用户数. 
b) 进一步改进你的程序, 不再一次写入一行, 而使用 pickle 模块保存整个数据对象. 请参
阅 pickle 模块的文档了解如何序列化/扁平化对象, 以及如何读写保存的对象. 一般来说, 这个
解决方案的代码行数要比 a) 的少. 
c) 使用 shelve 模块替换 pickle 模块, 由于可以省去一些维护代码，这个解决方案的代码比 
b) 的更少. 
 
*   9C13.   命令行参数 
a) 什么是命令行参数, 它们有什么用? 
b) 写一个程序, 打印出所有的命令行参数. 
 
*   9C14.  记录结果. 修改你的计算器程序(练习 5-6 )使之接受命令行参数. 例如: 
$ calc.py 1 + 2 
只输出计算结果. 另外, 把每个表达式和它的结果写入到一个磁盘文件中. 当使用下面的命令
时: 
$ calc.py print 
会把记录的内容显示到屏幕上, 然后重置文件. 这里是样例展示: 
 
$ calc.py 1 + 2 
3 
$ calc.py 3 ^ 3 
*   27 
$ calc.py print 
*   1 + 2 
3 
*   3 ^ 3 
*   27 
$ calc.py print 
$ 
 
附加题: 处理输入时候的注释. 
 
*   9C15.   复制文件. 提示输入两个文件名(或者使用命令行参数). 把第一个文件的内容复制
到第二个文件中去. 
 
*   9C16.   文本处理. 人们输入的文字常常超过屏幕的最大宽度. 编写一个程序, 在一个文本
文件中查找长度大于 80 个字符的文本行. 从最接近 80 个字符的单词断行, 把剩余文件插入到
下一行处. 
程序执行完毕后, 应该没有超过 80 个字符的文本行了. 
 
*   9C17.   文本处理. 创建一个原始的文本文件编辑器. 你的程序应该是菜单驱动的, 有如下
这些选项: 
1) 创建文件(提示输入文件名和任意行的文本输入), 
2) 显示文件(把文件的内容显示到屏幕), 
3) 编辑文件(提示输入要修改的行, 然后让用户进行修改), 
4) 保存文件, 以及 
5) 退出. 
 
*   9C18.   搜索文件. 提示输入一个字节值(0 - 255)和一个文件名. 显示该字符在文件中出现
的次数. 
 
*   9C19.   创建文件. 创建前一个问题的辅助程序. 创建一个随机字节的二进制数据文件, 但
某一特定字节会在文件中出现指定的次数. 该程序接受三个参数: 
*   1) 一个字节值( 0 - 255 ), 
2) 该字符在数据文件中出现的次数, 以及 
3) 数据文件的总字节长度. 

你的工作就是生成这个文件, 把给定的字节随机散布在文件里, 并且要求保证给定字符在文件
中只出现指定的次数, 文件应精确地达到要求的长度. 
 
*   9C20.   压缩文件. 写一小段代码, 压缩/解压缩 gzip 或 bzip 格式的文件. 可以使用命令
行下的 gzip 或 bzip2 以及 GUI 程序 PowerArchiver , StuffIt , 或 WinZip 来确认你的 Python 
支持这两个库. 
 
*   9C21.   ZIP 归档文件. 创建一个程序, 可以往 ZIP 归档文件加入文件, 或从中提取文件, 
有可能的话, 加入创建 ZIP 归档文件的功能. 
 
*   9C22.   ZIP 归档文件. unzip -l 命令显示出的 ZIP 归档文件很无趣. 创建一个 Python  
脚本 lszip.py , 使它可以显示额外信息: 压缩文件大小, 每个文件的压缩比率(通过比较压缩
前后文件大小), 以及完成的 time.ctime() 时间戳, 而不是只有日期和 HH:MM .  
提示: 归档文件的 date_time 属性并不完整, 无法提供给 time.mktime() 使用....这由你自
己决定. 
 
*   9C23.  TAR 归档文件. 为 TAR 归档文件建立类似上个问题的程序. 这两种文件的不同之处
在于 ZIP 文件通常是压缩的, 而 TAR 文件不是, 只是在 gzip 和 bzip2 的支持下才能完成压缩
工作. 加入任意一种压缩格式支持. 
附加题: 同时支持 gzip 和 bzip2 . 
 
*   9C24. 归档文件转换. 参考前两个问题的解决方案, 写一个程序, 在 ZIP (.zip) 和 
TAR/gzip (.tgz/.tar.gz) 或 TAR/bzip2 (.tbz/.tar.bz2) 归档文件间移动文件. 文件可能是已经
存在的, 必要时请创建文件. 
 
*   9C25. 通用解压程序. 创建一个程序, 接受任意数目的归档文件以及一个目标目录做为参数. 
归档文件格式可以是 .zip, .tgz, .tar.gz, .gz, .bz2, .tar.bz2,  .tbz 中的一种或几种. 程序
会把第一个归档文件解压后放入目标目录, 把其它归档文件解压后放入以对应文件名命名的目录下
(不包括扩展名). 例如输入的文件名为 header.txt.gz 和 data.tgz ，目录为 incoming , 
header.txt 会被解压到 incoming 而 data.tgz 中的文件会被放入 incoming/data . 
